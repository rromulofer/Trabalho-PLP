% Prof. Dr. Ausberto S. Castro Vera
% UENF - CCT - LCMAT - Curso de Ci\^{e}ncia da Computa\c{c}\~{a}o
% Campos, RJ,  2022
% Disciplina: Paradigmas de Linguagens de Programa\c{c}\~{a}o
% Aluno: Rômulo Souza Fernandes


\chapter{ Conceitos básicos da Linguagem Python}

Neste capítulo é apresentado alguns conceitos básicos da linguagem de programação Python, como Variáveis, constantes e tipos de dados básicos aceitos pela linguagem, que são inteiro, ponto flutuante, booleano, string e lista. Alguns dos livros indicados para iniciar o estudo sobre a linguagem de programação Python são:  \cite{Lutz2007}, \cite{Perkovic2016}, \cite{Severance2016}, \cite{Borges2014}, que foram os mesmos livros usados como base para escrever grande parte desse e outros capítulos.

    %%%%%%%%=================================
    \section{Variáveis e constantes}
    %%%%%%%%=================================
	De acordo com \cite{Severance2016} o Python possui um ótimo recurso, a manipulação de variáveis, essas variáveis são nomes atribuídos a valores, que possuem como propósito armazenar valores de forma que possam ser recuperados mais tarde. 
	Para criar variáveis é necessário fazer uma declaração por atribuição e assim atribuir valores a essas novas variáveis. 
	\begin{lstlisting}
	>>> texto = 'Hello, world!'
	>>> pi = 3,14159265
	>>> numero = 1500
	\end{lstlisting}
	No exemplo acima podemos observar a declaração por atribuição de 3 variáveis diferentes. A primeira está atribuindo uma string para uma variável, chamada texto, a segunda variável atribui o valor 3,14 e a variável possui o nome pi. Já a terceira variável, chamada numero está recebendo o valor 1500, também por atribuição. Os usuários tem uma grande liberdade na hora de escolher os nomes das variáveis, apenas não sendo possível usar palavras reservadas da linguagem como nome de uma variável.
	
	As constantes na linguagem Python, diferente de outras linguagens de programação, não podem ser criadas de forma que seu valor não seja alterado. Na documentação existem algumas orientações caso o usuário queira criar uma constante com sintaxe de variável, uma delas é que todas as letras da variável que será utilizada como constante, deverão ser maiúsculas, em casos do nome desejado possuir espaço, deverá ser utilizado underline.
	\begin{lstlisting}
	>>> PRECO = 5
	>>> PRECO_PRODUTO = 2
	\end{lstlisting}
	O exemplo acima é o padrão recomendado pela documentação do Python.

    %%%%%%%%=================================
    \section{Tipos de Dados Básicos}
    %%%%%%%%=================================
	A linguagem de programação Python é de tipagem dinâmica, com isso não é preciso declarar o tipo de variável, o tipo será definido através do valor que a variável receber, isso possibilita que o tipo mude no decorrer da execução do programa. Vamos falar sobre esses tipos de dados a seguir, com base nos autores \cite{Lutz2007}, \cite{Perkovic2016}, \cite{Severance2016}.
	
			\subsection{Inteiro}
			De acordo com o autor \cite{Perkovic2016}, o tipo inteiro ou \textit{int} representa caracteres numéricos inteiros positivos e negativos. Como já informado no texto anteriormente, na linguagem Python não é necessário informar o tipo da variável na sua declaração, o exemplo abaixo deixará isso mais claro.
			\begin{lstlisting}
   >>> n1 = 5
   >>> n2 = 10
   >>> soma = n1 + n2
   >>> print(soma)	
   >>> print(type(soma))		
   15
   <class 'int'>
			\end{lstlisting}
		
			\subsection{Ponto Flutuante}
			Com base no \cite{Perkovic2016}, o \textit{float} ou ponto flutuante é um tipo de dado usado para os números reais, pois eles possuem casas decimais, explicando melhor, são números com vírgula, como por exemplo um peso ou altura. Em uma expressão numérica, se um dos valores for um \textit{float}, o resultado da expressão será um \textit{float}, o exemplo abaixo irá demonstrar.
			\begin{lstlisting}
   >>> #exemplo utilizando ponto flutuante
   >>> peso = 1.77
   >>> altura = 62.50
   >>> print(type(peso))
   >>> print(type(altura))
   <class 'float'>
   <class 'float'>
   
   >>> #exemplo utilizando 1 ponto flutuante e 1 inteiro
   >>> a = 5
   >>> b = 2.5
   >>> soma = 5 + 2.5
   >>> print(soma)
   >>> print(type(resultado))
   7.5
   <class 'float'>
			\end{lstlisting}
		
			\subsection{Booleano}
			Segundo \cite{Perkovic2016}, o booleano é um tipo de dado lógico, utilizado parar armazenar valores lógicos, que no Python pode ser representado pelo valor True ou False. O True significando que o valor é verdadeiro e False significa que seu valor é falso. Seguimos com alguns exemplos do tipo de dado lógico booleano.
			\begin{lstlisting}
   >>> x = false
   >>> print(type(x))
   <class 'bool'>
   
   >>> #operacoes logicas
   >>> a = 10 < 5
   >>> print(a)
   False
   
   >>> b = c = 5
   >>> print(b <= c and c <= b)
   True
   
			\end{lstlisting}
     %%%........................
            \subsection{String}
     %%%........................
            Com base no autor \cite{Severance2016}, uma string é uma sequência de caracteres imutável, não permitindo alterar uma string que já existe. É classificado como um item de dado simples. Para o Python, uma string é um array de caracteres ou qualquer grupo de caracteres escritos entre aspas duplas ou aspas simples, por exemplo:
    \begin{lstlisting}
    >>> #Aspas simples
    >>> menssagem1 = 'Hello, World'
    >>> print (menssagem1)  
    Hello, World
    
    >>> #Aspas duplas
    >>> mensagem2 = "O dia esta chuvoso"
    >>> print (menssagem2)
    O dia esta chuvoso
    \end{lstlisting}
			
    \begin{itemize}
      \item \textit{Concatenação de strings}\\
            A união de strings é chamado de concatenação, isso pode ser feito utilizando o operador +, que possui essa função de concatenar quando usado com operandos do tipo string. O comprimento de uma string pode ser calculado utilizado o operador \texttt{len(string)}.
     \begin{lstlisting}
    >>> # concatenando 2 strings
    >>> moto = "Titan " + "150 ESD"
    >>> print (moto)
    Titan 150 ESD
    
    >>> print (len(moto))
    13
    \end{lstlisting}

      \item \textit{Operador de indexação}\\
      Utilizando o operador de indexação, é possível acessar os caracteres um por um, utilizando o operador colchetes, o número dentro do colchetes é denominado index, usado para indicar a posição do caractere da variável e atribuir esse caractere à uma variável.
      Existem duas formas de indexar os caracteres de um string em Python:\\
      \begin{description}
        \item[Index com inteiros positivos] indexando a partir da esquerda, começando com 0, sendo o 0 o index do primeiro caractere da sequência.
        \item[Index com inteiros negativos] indexando a partir da direita, começando com -1, sendo -1 o último elemento da sequência, -2 sendo o penúltimo elemento da sequência, e assim sucessivamente.
      \end{description}

     \begin{lstlisting}
     >>> #Inteiro positivo
     >>> moto = 'titan'
     >>> letra = moto[0]
     >>> print(letra)
     t
     
     >>>#inteiro negativo
     >>>moto = 'titan'
     >>>letra = moto[-1]
     >>>print(letra)
     n
        \end{lstlisting}


      \item \textit{Operador de Fatias}\\
      O operador de acesso a itens de forma individual, também pode ser usado como operador de fatias, podendo assim extrair uma fatia inteira (subsequência) de caracteres de uma string. O operador de Fatias dispõe de três sintaxes:\\
      \texttt{sequencia[ inicio ]}\\
      \texttt{sequencia[ inicio : fim ]} \\
      \texttt{sequencia[ inicio : fim : step ]}\\
      onde \texttt{início, fim} e \texttt{step} são números inteiros.
     \begin{lstlisting}
    >>> sequencia = 'Linguagem Python'
    >>> print(sequencia[0:9])
    Linguagem
    
    >>> print(sequencia[0:9:8])
    Lm
        \end{lstlisting}

    \end{itemize}

			\subsection{Lista}
			Segundo o autor \cite{Severance2016}, lista é uma sequência de objetos, diferente de uma string onde os valores são caracteres, na lista esses valores podem ser de qualquer tipo, até mesmo outras listas. Outra característica da lista que difere de uma string é que as listas são mutáveis, assim permitindo que o seu conteúdo seja modificado em qualquer momento, esse conteúdo das listas é chamado de elementos ou itens. Para criar uma lista é necessário colocar seus elementos apenas entre colchetes ou entre aspas dentro dos colchetes caso os elementos sejam caracteres.
			
			\begin{lstlisting}
	['verde ', 'amarelo', 'azul']
	[1, 2, 3, 4, 5]
			\end{lstlisting}
		A primeira lista do exemplo é formada por três strings, enquanto a segunda é formada por cinco números inteiros. Como já citado, é possível criar uma lista com elementos de tipos diferentes, como no exemplo a seguir, onde a lista contém uma lista, uma string, um float e um inteiro..
			
			\begin{lstlisting}
	[[1, 2], 'amarelo', 3.14, 100]
			\end{lstlisting}
		
		Também é possível atribuir valores de uma lista a variáveis.
		\begin{lstlisting}
	>>> numeros = [1, 2, 3, 4, 5]
	>>> cores = ['verde ', 'amarelo', 'azul']
	>>> lista_vazia = []
	
	>>> print(numeros, cores, lista_vazia)
	[1, 2, 3, 4, 5] ['verde ', 'amarelo', 'azul'] []
		\end{lstlisting}
	
	O acesso de elementos de uma lista é da mesma forma que o acesso de caracteres de uma string, o exemplo a seguir demonstra o funcionamento, o valor dentro dos [] é o índice.
	\begin{lstlisting}
		>>> print(cores[1])
		amarelo
	\end{lstlisting}
	Como as listas são mutáveis, é possível alterar seu conteúdo, atribuindo novos valores a itens ou mudando a ordem desses itens. A seguir temos um exemplo se como realizar essa alteração, observe que os [] a esquerda na atribuição significa o elemento que será alterado.
	\begin{lstlisting}
	>>> numeros = [1, 2, 3, 4, 5] 
	>>> numeros[0] = 6
	>>> print(numeros)
	[6, 2, 3, 4, 5]
	\end{lstlisting}

	\begin{itemize}
	\item {Operações com Listas}
	
	Novamente como nas strings, o + é o operador utilizado para concatenar listas e o * repete a lista determinada a quantidade de vezes desejada.
	
	\begin{lstlisting}
	>>> #concatenacao
	>>> numeros = [1, 2, 3]
	>>> cores = ['verde ', 'amarelo', 'azul']
	>>> concatena = numeros + cores
	>>> print(concatena)
	[1, 2, 3, 'verde ', 'amarelo', 'azul']
	
	>>> #repeticao de lista
	>>> print([1,2,3] * 3)
	[1, 2, 3, 1, 2, 3, 1, 2, 3]
	
	>>> print(['vermelho'] * 3)
	['vermelho', 'vermelho', 'vermelho']
	\end{lstlisting}

	\end{itemize}
     %%%%%%%%=================================
    \section{Tipos de Dados de Coleção}
    %%%%%%%%=================================


     %%%........................
            \subsection{Tipos Sequenciais}
     %%%........................
	 Com base em \cite{Severance2016}, as tuplas são sequências de valores parecidas com a lista, com a diferença que as tuplas são imutáveis, porém é possível cria uma tupla que contenha objetos mutáveis, um exemplo seria uma lista. Os valores para se armazenar podem ser de todos os tipos, são indexados usando números inteiros. A tupla é uma sequência de valores separados por vírgulas.
	\begin{lstlisting}
	>>> A = 123, 456, 'ola mundo'
	>>> A[1]
	456	
	\end{lstlisting}
	Para aninhar tuplas é necessário envolver por parênteses, permitindo que possam ser lidas corretamente. O uso de parênteses não é obrigatório para a criação de tuplas, apenas para tuplas dentro de expressões. A seguir temos uma demonstração.
	\begin{lstlisting}
	>>> B = A, (1, 2, 3)
	>>> B
	((123, 456, 'ola mundo'), (1, 2, 3))
	\end{lstlisting}
	

     %%%........................
            \subsection{Tipos Conjunto}
     %%%........................
	Segundo o autor \cite{Perkovic2016}, no Python um conjunto ou \textit{set} é uma coleção de itens fora de ordem, não podendo incluir itens duplicados. Desde que sejam imutáveis, as chaves podem ser de qualquer tipo. A linguagem oferece diferentes formas eficazes para criação e manipulação desses \textit{sets}, assim admitindo operadores para interseção, união, inclusão em conjunto, diferença simétrica, entre outros operadores disponíveis. Os \textit{sets} são definidos utilizando a mesma sintaxe utilizada para os conjuntos matemáticos, sendo itens separados por virgula e em sequência, sendo delimitados por chaves.
	\begin{lstlisting}
	>>> #criando e printando um conjunto
	>>> anotacao = {'123-456-789', '987-654-321',}
	>>> print(anotacao)
	{'987-654-321', '123-456-789'}
		
	>>> #verificando o tipo
	>>> type(anotacao)
	<class 'set'>
	\end{lstlisting}
	
     %%%........................
            \subsection{Tipos Mapeamento}
     %%%........................
	Com base no autor \cite{Severance2016}, na linguagem Python o dicionário é o único tipo de mapeamento nativo, seu funcionamento é como de uma lista, porém é mais geral. Explicando melhor, nas listas o índice necessariamente é um inteiro, já no dicionário o índice pode ser quase todos os tipos de dados. O dicionário é um mapeamento entre um conjunto de valores e índices, assim a chave que é o índice, é usado para localizar um valor. O dicionário é indicado por \textit{dict}.
		\begin{lstlisting}
  >>> #criando e printando um dicionario
  >>> dic = {'gasolina': 5.30, 'alcool': 4.30, 'GNV': 4.50}
  >>> print(dic)
  {'gasolina': 5.3, 'alcool': 4.3, 'GNV': 4.5}
  
  >>> #item que localiza pela chave 'GNV'
  >>> print(dic['GNV'])
  4.5
	\end{lstlisting}
	Como mostrado no exemplo acima, a chave 'GNV' sempre irá localizar o valor 4.5, assim mostrando também que a ordem dos itens não interfere.

    %%%%%%%%=================================
    \section{Estrutura de Controle e Funções}
    %%%%%%%%=================================
	
     %%%........................
            \subsection{O comando IF}
     %%%........................
			Com base nos autores \cite{Perkovic2016} e \cite{Severance2016}, o \textit{if} é uma estrutura de controle, sendo de decisão fundamental, permitindo a execução de blocos de códigos alternativos, se baseando em condições.
			\begin{lstlisting}
	>>> if A > 0
	>>> 	print('A e um numero positivo')
	
			\end{lstlisting}
			 Depois da declaração textit{if} temos uma expressão booleana, essa expressão é a condição. Como vemos no exemplo acima, a declaração termina com o símbolo de dois pontos (:) e a linha após o textit{if} devem ser indentadas. A condição lógica sendo verdadeira, logo a declaração é executada, caso seja falsa, a condição é ignorada.
			 
			 As declarações que se alongam por mais de uma linha e consistem em uma linha de cabeçalho e um bloco indentado, são chamadas de extit{declarações compostas}. O número de declarações possíveis não tem um limite, porém é obrigatório que tenha no mínimo uma. 
			 
			 \begin{itemize}
			 	\item \textit{Execução alternativa}
			 	
			 	 A \textit{Execução alternativa} é a segunda forma de declarar um \textit{if}, nessa declaração existem duas possibilidades e a sua condição, que irá determinar qual delas será executada. Abaixo temos uma demonstração se o número é par ou ímpar.
			 	 \begin{lstlisting}
	>>> if A%2 == 0
	>>>	print('A e Par')
	>>> else:
	>>>	print('A e Impar')

			 	 \end{lstlisting}
				\item \textit{Condição encadeada}
				
				A condição encadeada é um jeito de expressar uma lógica computacional, utilizada quando existe mais de uma possibilidade e necessitamos de mais de duas ramificações. 
				
				\begin{lstlisting}
	>>> if n1 < n2:
	>>>	print('n1 e menor que n2')
	>>> elif n1 > n2:
	>>>	print('n1 e maior que n2)
	>>> else:
	>>>	print('n1 e n2 sao iguais')
					
				\end{lstlisting}
			
				\item \textit{Condição aninhadas}
				Também podemos escrever com 3 ramos, assim a condição passará a ser aninhada, vamos exemplificar na demostração abaixo.
					\begin{lstlisting}
	>>> if n1 == n2:
	>>>	print('n1 e n2 sao iguais')
	>>> else:
	>>>	if p1 < p2:	
	>>>	    print('n1 e menor que n2)
	>>>	else:
	>>>	    print('n1 e maior que n2')
					
				\end{lstlisting}
			 \end{itemize}
			  
      %%%........................
            \subsection{Laço FOR}
     %%%........................
	Segundo \cite{Severance2016}, podemos criar um laço definido utilizando uma declaração \textit{for}, quando temos um conjunto de itens para iterar. É chamado de laço definido pois irá iterar sobre uma lista de itens até que o número de iterações seja o mesmo de itens da lista. Abaixo temos um exemplo de declaração \textit{for}, onde o \textit{for} e \textit{in} são palavras-chave reservadas do Python, colegas e colega são variáveis, colega em específico é uma \textit{variável de iteração} do laço \textit{for}, que percorre o conteúdo da variável amigos, mudando a cada iteração, assim controla quando o laço deve finalizar.
	\begin{lstlisting}
	>>> colegas = ['Marta', 'Lucas', 'Diego']
	>>> for colega in colegas:
	>>>	print('Bom dia', colega)
	Bom dia Marta
	Bom dia Lucas
	Bom dia Diego
		
	\end{lstlisting}
	Para o Python, a variável colegas é considerada uma lista contendo 3 cadeias de caracteres e um laço \textit{for}, que percorrerá a lista e executará o corpo 1 vez para cada palavra da lista, por isso a saída mostra a mensagem para todo os colegas da lista.
     %%%........................
            \subsection{Laço WHILE}
     %%%........................
	De acordo com \cite{Severance2016}, a linguagem Python oferece vários recursos para tornar a automatização de tarefas repetitivas mais fácil. No Python, o \textit{while} é uma forma de iteração. A seguir temos uma demonstração de uso do \textit{while} e também podemos perceber novamente a clareza da sintaxe do Python, a declaração pode ser lida como uma frase usual.
	\begin{lstlisting}
	>>> x = 2
	>>> while x > 0:
	>>>	print(x)
	>>>	x = x-1
	>>> print('Go!!!')
		
	\end{lstlisting}
	O fluxo de execução é, analisar a condição, assim retornando o valor \textit{True} ou \textit{False}, caso a condição seja falsa, sai da declaração e segue para as próximas declarações, já caso seja verdadeira, executa o bloco \textit{while} e retorna para o primeiro passo, que é analisar a condição. O bloco de instruções também pode ser chamado de \textit{laço}, visto que o terceiro e último passo retorna para o primeiro. A cada vez que as instruções internas de um laço são executadas, chamamos de \textit{iteração}. A \textit{variável de iteração} é a variável que tem seu valor modificado a cada execução do laço, assim controlando quando o laço deve acabar. Podemos chamar uma declaração \textit{while} de laço indefinido, pois a declaração continua iterando até que uma das condições seja falsa. \cite{Severance2016}
	
	
    %%%%%%%%======================
    \section{Módulos e pacotes}
    %%%%%%%%======================



       %%%........................
            \subsection{Módulos}
     %%%........................
	Baseado em \cite{Perkovic2016}, os módulos são arquivos que contém definições e instruções, são utilizados em uma execução ou script interativa do interpretador. Essas definições podem ser importadas para o módulo principal ou outro módulo. O arquivo tem mesmo nome do módulo porém com o acréscimo do \textit{.py}. O próprio Python possui uma variedade de módulos na sua biblioteca padrão. Após a importação do módulo podemos usar as instruções e definições que estão contidas nele. Abaixo um exemplo prático. 
	\begin{lstlisting}
	>>> # Modulo de numeros Fibonacci 
	>>> def fib(n):   
	>>>	x, y = 0, 1
	>>>	while x < n:
	>>>		print(x, end=' ')
	>>>		x, y = y, x+y
	>>>	print()
		
	>>> def fib2(n):   
	>>>	resultado = []
	>>>	x, y = 0, 1
	>>>	while x < n:
	>>>		resultado.append(x)
	>>>		x, y = y, x+y
	>>>	return resultado
	\end{lstlisting}

	Esse deverá ser o conteúdo do arquivo \textit{fibo.py}, após é necessário importar esse módulo pelo interpretador, para isso basta inserir o comando:
	
	\begin{lstlisting}
	>>> import fibo
	\end{lstlisting}
	Com isso os nomes das funções definidas não serão adicionados, apenas o nome do módulo é acrescentado. Utilizando o nome é possível acessar as funções.
	\begin{lstlisting}
	>>> fibo.fib(1000)
	0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
	
	>>> fibo.fib2(100)
	[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
	
	>>> fibo.__name__
	'fibo'
	\end{lstlisting}
	Como dito, o Python oferece uma diversidade de módulos na biblioteca padrão. No próprio interpretador existem alguns desses módulos, permitindo o acesso a operações de fora do núcleo da linguagem. O \textit{winreg} e \textit{sys} são um exemplos de módulos padrão. \cite{Perkovic2016}
          %%%........................
            \subsection{Pacotes}
     %%%........................
	Segundo \cite{Borges2014}, uma coleção de módulos é considerado um pacote, são utilizados quando os módulos tomam grandes proporções de tamanho, podendo assim dividir esses módulos em pacotes. Para evitar que, os autores de módulos se preocupem com colisão entre os nomes de variáveis globais dos seus módulos e de outros autores, é necessário usar os pacotes.
	
	Enquanto os módulos são estruturados em arquivos, os pacotes são estruturados em pastas. A ferramenta utilizada para gerenciar esses pacotes no Python é o PIP, que significa em português, Índice de Pacotes Python. O PIP permite que através dele pacotes sejam instalados, atualizados e removidos em projetos. Seu uso é simples, basta utilizar o comando \textit{pip install} e o nome do pacote desejado. Exemplo:
	\begin{lstlisting}
	>>> pip install NumPy
	\end{lstlisting}
	Em seguida o gerenciador fará o download e a instalação do pacote. Alguns dos pacotes mais utilizados no Python são: NumPy, Pillow, Matplotlib, OpenCV, Delorean, Scipy, Pandas, Requests, Fire, etc.





