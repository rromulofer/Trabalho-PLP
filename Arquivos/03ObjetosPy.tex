% Prof. Dr. Ausberto S. Castro Vera
% UENF - CCT - LCMAT - Curso de Ci\^{e}ncia da Computa\c{c}\~{a}o
% Campos, RJ,  2022
% Disciplina: Paradigmas de Linguagens de Programa\c{c}\~{a}o
% Aluno: Rômulo Souza Fernandes


\chapter{ Programação Orientada a Objetos com Python}

	 Como sabemos a programação orientada a objetos é um dos paradigmas da linguagem Python. Com isso trás ótimas e poderosas ferramentas que auxiliam. Como a . Outra ferramenta muito poderosa é a herança. 

   %%%%%%%%======================
    \section{Classes e Objetos}
    %%%%%%%%======================
    
	 No Python uma entidade é representada por uma abstração computacional, chamada objeto, que possui os atributos que são as qualidades e os métodos que são as ações que a entidade pode fazer. Na orientação a objetos, classe é a estrutura básica, simbolizando o tipo de um objeto, assim definindo o que o objeto pode realizar e suas características. A seguir temos um exemplo simples de como definir uma classe:
	 \begin{lstlisting}
   class NomedaClasse:
   <declaracao-1>
   .
   .
   .
   <declaracao-N>
	 \end{lstlisting}
	  
	 Para que o objeto permaneça na memória é preciso de no mínimo uma referência, pois o interpretador da linguagem Python tem uma ferramenta de limpeza que exclui todos os objetos que não possuem referência, essa ferramenta é chamada de coletor de lixo ou \textit{Garbage Collector}, assim que os objetos sem referência são excluídos o \textunderscore\textunderscore \textit{done}\textunderscore\textunderscore(), outro método especial, é executado.
	 
	Há diversos motivos para o Python aceitar que classes novas sejam definidas por desenvolvedores, um dos motivos é que o programa de aplicação será mais simples de desenvolver, ler, depurar e intuitivo, através das classes projetadas unicamente para essa aplicação. Junto com a possibilidade de criar classes novas é permitido um novo jeito de estruturar um programa de aplicação. O comportamento de uma função é exposto ao usuário, mas sua implementação é encapsulada(ocultada) \cite{Borges2014}. 
	
	A seguir temos uma demonstração de uso do objeto no Python:
	
   \begin{lstlisting}
    stuff = list()
    stuff.append('python')
    stuff.append('chuck')
    stuff.sort()
    print (stuff[0])
    print (stuff.__getitem__(0))
    print (list.__getitem__(stuff,0))
    \end{lstlisting}
	
	Na primeira linha um objeto do tipo \textit{list} é construído, na segunda e terceira linhas do código o método \textit{append()} é chamado, na quarta linha o método \textit{sort()} é chamado, na quinta linha o item da posição 0 é recuperado. 
	
	Na sexta linha o método \textunderscore\textunderscore \textit{getitem}\textunderscore\textunderscore()  com 0 como parâmetro, é chamado na lista \textit{stuff}.
	\begin{lstlisting}
    print (stuff.__getitem__(0))
	\end{lstlisting}

	Na sétima linha mostra como recuperar o primeiro item da lista de uma forma mais detalhada.
	\begin{lstlisting}
    print (list.__getitem__(stuff,0))
	\end{lstlisting}
	
	Neste código o método \textunderscore\textunderscore \textit{getitem}\textunderscore\textunderscore () é chamado na classe \textit{list} e também é passado o item que deve ser recuperado e a lista como parâmetro. As 3 últimas linhas do código percebemos que são semelhantes, porém fazer uso da sintaxe com os colchetes ([ ]) é mais adequado para visualizar um item em uma posição específica da lista \cite{Severance2016}.
	
   %%%%%%%%======================
    \section{Operadores ou Métodos}
    %%%%%%%%======================
	Como já vimos, um métodos é uma função utilizada para detalhar o comportamento do objeto. Os métodos que conseguem se aplicar aos objetos da classe são expostos ao usuário, mas o modo como essas informações inclusas nos objetos são salvas é encapsulado, além de encapsular o modo como os métodos das classes estão sendo implementados.
	 
	Um operador é uma chamada para os métodos especiais. Os métodos especiais são caracterizados pelos nomes que possuem um padrão, utilizando 2 sublinhados no começo e 2 no final de cada nome, definindo de que forma os objetos que são derivados da classe devem funcionar em cados específicos, conforme na sobrecarga de operadores \cite{Borges2014}.
	
	 Na linguagem de programação Python um objeto é criado com base na classe e usando a atribuição. O construtor dessas classes que é um método especial, entra em execução quando novos objetos são criados. Esse construtor é chamado de \textunderscore\textunderscore \textit{new}\textunderscore\textunderscore(), depois de chamar o construtor para inicializar uma nova instância é chamado o método \textunderscore\textunderscore \textit{init}\textunderscore\textunderscore(). Uma forma da classe definir um método especial \textunderscore\textunderscore \textit{init}\textunderscore\textunderscore() é:
	 \begin{lstlisting}
   def __init__(self):
   self.data = []
	 \end{lstlisting}
	 
	
   %%%%%%%%======================
    \section{Herança}
    %%%%%%%%======================
	

   %%%%%%%%======================
    \section{Estudo de Caso: }
    %%%%%%%%====================== 