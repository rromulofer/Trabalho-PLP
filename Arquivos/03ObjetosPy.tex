% Prof. Dr. Ausberto S. Castro Vera
% UENF - CCT - LCMAT - Curso de Ci\^{e}ncia da Computa\c{c}\~{a}o
% Campos, RJ,  2022
% Disciplina: Paradigmas de Linguagens de Programa\c{c}\~{a}o
% Aluno: Rômulo Souza Fernandes


\chapter{ Programação Orientada a Objetos com Python}

	 Como sabemos, a Programação Orientada a Objetos (POO) é um dos paradigmas da linguagem Python, com base no conceito de classes e objetos. Com isso trás ótimas e poderosas ferramentas que auxiliam no desenvolvimento de softwares seguros e confiáveis, uma dessas ferramentas que auxiliam é herança, que evita trabalhos repetidos, permite também que o desenvolvedor codifique com maior velocidade, poupando tempo. Esse paradigma é voltado para os objetos desejados pelos desenvolvedores, ao contrário da lógica precisa para manipular. A seguir vamos explicar e demonstrar cada conceito da Programação Orientada a Objetos.

   %%%%%%%%======================
    \section{Classes e Objetos}
    %%%%%%%%======================
    
	 No Python uma entidade é representada por uma abstração computacional, chamada objeto, que possui os atributos que são as qualidades e os métodos que são as ações que a entidade pode fazer. Na orientação a objetos, classe é a estrutura básica, simbolizando o tipo de um objeto, assim definindo o que o objeto pode realizar e suas características. A seguir temos um exemplo simples de como definir uma classe:
	 \begin{lstlisting}
   class NomedaClasse:
   <statement-1>
   .
   .
   .
   <statement-N>
	 \end{lstlisting}
	  
	 Para que o objeto permaneça na memória é preciso de no mínimo uma referência, pois o interpretador da linguagem Python tem uma ferramenta de limpeza que exclui todos os objetos que não possuem referência, essa ferramenta é chamada de coletor de lixo ou \textit{Garbage Collector}, assim que os objetos sem referência são excluídos o \textunderscore\textunderscore \textit{done}\textunderscore\textunderscore(), outro método especial, é executado.
	 
	Há diversos motivos para o Python aceitar que classes novas sejam definidas por desenvolvedores, um dos motivos é que o programa de aplicação será mais simples de desenvolver, ler, depurar e intuitivo, através das classes projetadas unicamente para essa aplicação. Junto com a possibilidade de criar classes novas é permitido um novo jeito de estruturar um programa de aplicação. O comportamento de uma função é exposto ao usuário, mas sua implementação é encapsulada(ocultada) \cite{Borges2014}. 
	
	A seguir temos uma demonstração de uso do objeto no Python:
	
   \begin{lstlisting}
    stuff = list()
    stuff.append('python')
    stuff.append('chuck')
    stuff.sort()
    print (stuff[0])
    print (stuff.__getitem__(0))
    print (list.__getitem__(stuff,0))
    \end{lstlisting}
	
	Na primeira linha um objeto do tipo \textit{list} é construído, na segunda e terceira linhas do código o método \textit{append()} é chamado, na quarta linha o método \textit{sort()} é chamado, na quinta linha o item da posição 0 é recuperado. 
	
	Na sexta linha o método \textunderscore\textunderscore \textit{getitem}\textunderscore\textunderscore()  com 0 como parâmetro, é chamado na lista \textit{stuff}.
	\begin{lstlisting}
    print (stuff.__getitem__(0))
	\end{lstlisting}

	Na sétima linha mostra como recuperar o primeiro item da lista de uma forma mais detalhada.
	\begin{lstlisting}
    print (list.__getitem__(stuff,0))
	\end{lstlisting}
	
	Neste código o método \textunderscore\textunderscore \textit{getitem}\textunderscore\textunderscore () é chamado na classe \textit{list} e também é passado o item que deve ser recuperado e a lista como parâmetro. As 3 últimas linhas do código percebemos que são semelhantes, porém fazer uso da sintaxe com os colchetes ([ ]) é mais adequado para visualizar um item em uma posição específica da lista \cite{Severance2016}.
	
   %%%%%%%%======================
    \section{Operadores ou Métodos}
    %%%%%%%%======================
	De acordo com o autor \cite{Borges2014}, um métodos é uma função utilizada para detalhar o comportamento do objeto. Os métodos que conseguem se aplicar aos objetos da classe são expostos ao usuário, mas o modo como essas informações inclusas nos objetos são salvas é encapsulado, além de encapsular o modo como os métodos das classes estão sendo implementados.
	 
	Um operador é uma chamada para os métodos especiais. Os métodos especiais são caracterizados pelos nomes que possuem um padrão, utilizando 2 sublinhados no começo e 2 no final de cada nome, definindo de que forma os objetos que são derivados da classe devem funcionar em cados específicos, conforme na sobrecarga de operadores.
	
	 Na linguagem de programação Python um objeto é criado com base na classe e usando a atribuição. O construtor dessas classes que é um método especial, entra em execução quando novos objetos são criados. Esse construtor é chamado de \textunderscore\textunderscore \textit{new}\textunderscore\textunderscore(), depois de chamar o construtor para inicializar uma nova instância é chamado o método \textunderscore\textunderscore \textit{init}\textunderscore\textunderscore(). Uma forma da classe definir um método especial \textunderscore\textunderscore \textit{init}\textunderscore\textunderscore() é:
	 \begin{lstlisting}
   def __init__(self):
   self.data = []
	 \end{lstlisting}
	 
	
   %%%%%%%%======================
    \section{Herança}
    %%%%%%%%======================
	A herança é uma grande ferramenta do Python, devido a programação orientada a objetos. Essa ferramenta possui objetivo de facilitar o reaproveitamento de códigos. Organizando as classes definidas pelo usuário é possível reutiliza-las em outros códigos, de forma semelhante que é possível utilizar uma função no desenvolvimento de outra função. Assim novos atributos e métodos podem ser implementados por uma nova classe e ao mesmo tempo a classe pode herdar atributos e métodos de uma classe antiga. Além disso as classes podem ser estendidas em uma classe nova através da herança de classes. 
	
	Existem 2 tipos de heranças, simples e múltipla. Na herança simples a classe pode derivar apenas de uma classe que já existe, diferentemente na herança múltipla a classe deriva de diversas classes que já existem, outra diferença é na ordem de resolução dos métodos, seguindo o algoritmo diamante \cite{Borges2014}.
	
	A seguir uma demonstração de herança simples e herança múltipla: 
	
	\begin{lstlisting}
    # Heranca simples
    class DerivedClassName(BaseClassName):
    <statement-1>
    .
    .
    .
    <statement-N>
		
    # Heranca multipla
    class DerivedClassName(Base1, Base2, Base3):
    <statement-1>
    .
    .
    .
    <statement-N>
	\end{lstlisting}
